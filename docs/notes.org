* std::sort arg vs string.compare                           jun 18 2020
=std::sort= can take a comparison function as an argument.  This comparison
argument must return something that's castable to =bool=.  =string::compare=
returns an integer: -1 if less than, 0 if equal, 1 if greater than.  If this
gets cast to a bool, the sort does not behave as expected.  To create the
correct argument for std::sort, one must compare the two strings and then check
if the result of that is less than (or equal to) zero.

(a, b -> a.compare(b) <= 0)


* nonterminating menus considered harmful                   jun 18 2020
The lifetimes of daemon menus would be hard to keep track of, so I'm going to
prefer using only terminating menus.  Every menu lives while it's on screen,
transitions to a different menus using some actions, and terminates to a buffer
using other actions.

Some kinds of menus might need to be daemon, or might otherwise be preferred to
be daemon by the user.  For now I'm not going to worry about those.


* kinds of menus                                            jun 17 2020
- daemon menus
- terminating menus/transition menus


* the myth of non-integral laptop scrolling                 jun 15 2020
I always thought that laptops scrolled with a floating point amount of
precision as you scrolled down, and that may be the case on Windows
with Windows Precision Drivers, but that definitely isn't the case on
Linux.

GLFW only detects +/- 1 scroll_y.  Testing even on chrome, it seems to
only detect integer-based up and down scrolls.  That definitely isn't
the case on mobile.


* layered buffers, text and rectangles                      jun 15 2020
Drawing text is complicated.  Text is usually drawn with a textured
rectangle and some of the pixels are partially colored, and others are
completely opaque or transparent.

To draw a rectangle after the text but have the rectangle appear under
the text, there must be a depth buffer that allows for a depth test to
occur.  With that, OpenGL can use the Z variable to check the
depth.  The real problem lies with the partially colored fragments.

If the text is white and it is being drawn on a red background, the
partially colored pixels are pink.  If then a black background is
drawn below the white text, it will still have a pink periphery
instead of having a grey periphery.  There are many solutions to this
problem.  There are also many tradeoffs to consider.

The tradeoffs include:
- minimizing the number of draw calls during a frame
- allowing the pages to be re-ordered
- allowing for text highlighting
- allowing for moving pages around

The solutions I can think of are listed below.

1. *Blank Texture*
   We could draw the text to a texture with a transparent background.
   We could then use the texture to redraw the text that has been
   black-backgrounded.

2. *Negative Space*
   We could clear the screen with the correct background color and
   only actually draw the negative space.

3. *Background Color Texture*
   We could draw the text to a texture with the correct background
   color and use that to render the text.  This requires knowing the
   background color of the text before drawing the background.  This
   would allow batching the backgrounds.

4. *Multiple Draw Calls*
   I could just draw all of the rectangles and texts in the correct
   order, and redraw all of them when it is reordered.

5. *Background First*
   I could draw the text after all the backgrounds are drawn.

6. *Discard*
   I could discard the pixels from the text's fragment shader.  This
   does not avoid the problem of the partially colored pixels that are
   drawn on the wrong background, but it is simple enough to do.

7. *Dirty Draw*
   Only redraw when necessary.  For scrolling, draw to image.  The
   rest of these solutions are built around the assumption of
   redrawing every frame, this one is not.

8. *Background Color Argument*
   We could modify the text renderer's shader to also take in a
   background color.  We can use that to linearly interpolate with
   instead of using a "blank" color.  This might also simplify
   highlighting, so as long as the highlight does not go partially
   through a character of the text.  If a character only has its left
   half highlighted, then we'll need a highlight texture and that's
   basically the same as 3's *Background Color Texture*.

For now I've chosen option 6, because it requires the smallest change
from the current code.  I'll revisit this in the future.  I suspect
the final solution will take bits and pieces from many of these
sections.

When I decide to return to this, I'll probably do a combination of 5
and 8.  The advanced solution would probably consider something like 7
and 1 through 4.


* c++ suspicion                                             jun 12 2020
=> c++
I'm going to refrain from using a large part of the c++ language because I plan
on rewriting this in backbone.

Here are some parts I think are suspicious, and thus are not going to be in backbone:
- constructors, destructors
  - tying together allocation and initialization is bad
  - it makes it so that you have weird problems with references and move
    semantics
    - e.g. when you delete an element of the array, you need to destroy it but not
      de-allocate it.  thus you get "in-place delete".
  - thus there's no RAII
- inheritance
  - inheritance bad
  - virtual bad

By avoiding these two things, we don't have to deal with the "rule of 3" (or
5).  We do have to think a little harder about memory management, but I believe
that being careful initially will save us the headache of looking at c++
template pointer error output in the future (delete an element in a vector of a
inherited type).


* chdir can't be in shell                                   jun 11 2020
=> menu
- git commit: db660aa247d67a02a7f80170238763a621854fec

To make a menu, you have to pass in a function table that will handle different
kinds of buttons on the menu.

Each button has its first child, a visual representation, which currently should
be an atomic Texp because each button is expected to sit on a single line.

The second child is a /command/.  The value of the command tells the menu which
function from the function table to use.  It indexes the function table to get
the function, called the /handler/, and then it calls that function.  It calls
the function with its first and only child as the argument.  Thus the function should be of the
type =Texp -> void= in the host language.

The =shell= command type calls =man 3 system()= with the argument, expected to
be a atomic string.  =system= calls =fork=, thus the shell command does not
execute in the current process, but in the child process.  What we want is
for it to call =man 2 chdir= in the current process, so we'll just create an
=man 1 cd= specific handler that simply calls =chdir=.
